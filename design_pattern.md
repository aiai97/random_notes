## 创建型模式（Creational Patterns）：

### 工厂模式（Factory Pattern）：
定义一个创建对象的接口，由子类决定实例化的具体类。
### 抽象工厂模式（Abstract Factory Pattern）：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。
### 单例模式（Singleton Pattern）：
保证类只有一个实例，并提供全局访问点。
### 建造者模式（Builder Pattern）：
将复杂对象的构建过程与其表示分离，以便可以独立地创建不同的表示。
### 原型模式（Prototype Pattern）：
通过复制现有对象来创建新对象，而无需显式地使用构造函数。
## 结构型模式（Structural Patterns）：
### 适配器模式（Adapter Pattern）：
将一个类的接口转换成客户希望的另一个接口。
### 桥接模式（Bridge Pattern）：
将抽象部分与实现部分分离，使它们可以独立地变化。
### 组合模式（Composite Pattern）：
将对象组合成树形结构以表示“部分-整体”的层次结构。
### 装饰器模式（Decorator Pattern）：
动态地给对象添加额外的职责。
### 外观模式（Facade Pattern）：
为子系统中的一组接口提供一个统一的接口。
## 行为型模式（Behavioral Patterns）：

### 观察者模式（Observer Pattern）：
定义对象间的一对多依赖关系，使得当一个对象改变状态时，其他依赖对象会被通知并自动更新。
### 策略模式（Strategy Pattern）：
定义一系列算法，将其封装成可互换的对象，从而使得算法可独立于客户端而变化。
### 职责链模式（Chain of Responsibility Pattern）：
将请求的发送者和接收者解耦，并允许多个对象对请求进行处理。
### 迭代器模式（Iterator Pattern）：
提供一种顺序访问聚合对象中各个元素的方法，而无需暴露其内部表示。
### 状态模式（State Pattern）：
允许对象在其内部状态改变时改变其行为。
### 命令模式（Command Pattern）：
将请求封装成对象，从而使得可以用不同的请求对客户进行参数化。
## 其他模式：
### MVC模式（Model-View-Controller Pattern）：
将应用程序分为三个核心组件，以实现用户界面、数据处理和控制逻辑的分离。
### MVVM模式（Model-View-ViewModel Pattern）：
将应用程序分为三个核心组件，以实现用户界面、数据和视图模型的分离。
### 备忘录模式（Memento Pattern）：
在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
### 访问者模式（Visitor Pattern）：
将算法与其所作用的对象分离，使算法可以独立于对象结构而变化。


创建型模式：
工厂模式：
当需要根据不同的条件创建不同类型的对象时，例如在电商平台中根据用户选择的商品类型创建对应的商品对象时，可以使用工厂模式。
抽象工厂模式：
当需要创建一系列相关或相互依赖的对象时，例如在银行系统中创建不同类型的账户对象和对应的交易对象时，可以使用抽象工厂模式。
单例模式：
当需要确保系统中只有一个实例存在时，例如在数据库连接池中只允许存在一个实例，可以使用单例模式。
原型模式：
场景：当需要通过复制现有对象来创建新对象时。
举例：在一个游戏中，玩家可以克隆一个已有的角色来创建新的角色实例。
建造者模式：
场景：当需要创建复杂对象，并希望灵活地构建不同的对象时。
举例：在一个电商平台中，通过建造者模式创建订单对象，可以按需选择商品、数量、地址等信息来构建订单。
结构型模式：

适配器模式：
场景：当需要将不同接口转换为统一接口时。
举例：在一个支付系统中，将不同支付渠道的接口适配为统一的支付接口，使得不同渠道可以统一处理支付请求。
桥接模式：
场景：当需要将抽象部分和具体实现部分分离，并且它们可以独立地变化时。
举例：在一个电商平台中，将商品的分类和展示方式进行解耦，使得可以独立地对分类和展示方式进行扩展和修改。
组合模式：
场景：当需要表示部分-整体层次结构，并且希望客户端对单个对象和组合对象的处理保持一致时。
举例：在一个电商平台中，处理商品的分类和子分类的场景，可以使用组合模式来统一处理商品的展示和操作。
装饰器模式：
场景：当需要在不修改原始对象的情况下，动态地为对象添加额外功能时。
举例：在一个电商平台中，为商品对象添加折扣、促销等功能，可以使用装饰器模式来动态地为商品对象添加额外的功能。
外观模式：
场景：当需要为子系统提供一个简化接口，并且客户端只需要与外观对象进行交互时。
举例：在一个电商平台中，为用户提供统一的下单接口，隐藏了下单过程的复杂性，客户端只需要与外观对象进行交互。
行为型模式：

观察者模式：
场景：当需要实现对象间一对多依赖关系，当一个对象的状态发生变化时，所有依赖对象会自动得到通知。
举例：在一个新闻订阅应用程序中，订阅者可以接收到新闻发布者发布的最新新闻。
策略模式：
场景：当需要在运行时根据不同条件选择不同算法或行为时。
举例：在一个电商平台中，根据用户的积分等级不同，使用不同的折扣策略来计算商品的实际价格。
职责链模式：
场景：当需要将请求的发送者和接收者解耦，并且允许多个对象对请求进行处理时。
举例：在一个审批流程系统中，一个请求需要经过多个审批节点才能最终被处理。
迭代器模式：
场景：当需要顺序访问聚合对象中的元素时，隐藏了迭代的具体实现，使得访问聚合对象的方式更加简洁和灵活。
举例：在一个电商平台中，迭代器模式可以用于遍历商品列表，进行商品的展示和操作。
状态模式：
场景：当对象的行为取决于其内部状态的变化时，通过将状态的行为封装在不同的对象中，实现对象行为的动态切换。
举例：在一个游戏中，角色的行为随着不同的状态（如正常、受伤、无敌）发生变化，可以使用状态模式来管理角色的行为。
命令模式：
场景：当需要将请求封装成对象，并在不同的时间点执行或排队请求时。
举例：在一个文本编辑器应用程序中，将用户的编辑操作封装成命令对象，可以实现撤销、重做等功能。]()


备忘录模式：
假设你正在开发一个文本编辑器应用程序。你可以使用备忘录模式来实现撤销和恢复功能，让用户可以保存当前编辑状态，并在需要时回退到先前的状态。
访问者模式：
假设你正在开发一个博物馆导览应用程序。你可以定义一个访问者接口和具体的访问者类，每个访问者可以对不同类型的展品进行特定的操作，如观看、收藏或评论。
解释器模式：
假设你正在开发一个简单的数学表达式解析器。你可以使用解释器模式来解析和计算数学表达式，将表达式拆分成语法树，并根据语法规则进行计算。
中介者模式：
假设你正在开发一个多人在线游戏。你可以使用中介者模式来管理玩家之间的通信和交互，所有的消息和动作都通过中介者进行处理和转发。
委托模式：
假设你正在开发一个任务调度系统。你可以定义一个委托接口和具体的委托类，每个委托类负责执行特定的任务，并将结果报告给调度器。
模板方法模式：
假设你正在开发一个咖啡制作程序。你可以定义一个咖啡制作的模板方法，包括冲泡咖啡、加入调料等步骤，具体的咖啡类型可以通过子类来实现。
迭代器模式：
假设你正在开发一个社交媒体应用程序。你可以使用迭代器模式来遍历用户的好友列表或浏览新闻源的文章列表。
规格模式：
假设你正在开发一个电商网站。你可以使用规格模式来定义产品的规格和筛选条件，根据用户的选择来过滤符合条件的产品列表。
过滤器模式：
假设你正在开发一个电商网站，用户可以根据不同的条件筛选产品。你可以使用过滤器模式来实现筛选功能，根据用户选择的条件过滤产品列表，如按价格、品牌或评分进行筛选。
外部配置模式：
假设你正在开发一个应用程序，需要从外部配置文件中加载配置参数。你可以使用外部配置模式，将配置文件的读取和解析过程封装起来，使得应用程序可以灵活地读取和使用配置参数。
数据访问对象模式：
假设你正在开发一个电子商务平台，需要对数据库进行操作。你可以使用数据访问对象模式来封装数据库操作，提供统一的接口来访问和操作数据库，从而降低数据库访问的复杂性。
连接池模式：
假设你正在开发一个高并发的网络应用程序，需要频繁地创建和销毁网络连接。你可以使用连接池模式来管理网络连接的生命周期，重复使用已有的连接，减少资源的开销。
责任链模式：
假设你正在开发一个审批流程系统，一个请求需要经过多个审批节点才能最终被处理。你可以使用责任链模式来构建审批流程，每个审批节点都可以决定是否处理请求，并将请求传递给下一个节点。
并发模式：
假设你正在开发一个并发程序，需要处理多个线程之间的同步和通信。你可以使用并发模式来解决并发编程中的常见问题，如互斥访问、线程间通信和任务调度等。
模板模式：
假设你正在开发一个自动化测试框架，其中包含多个测试用例。你可以使用模板模式定义一个测试用例的基本执行流程，并在具体的测试用例中实现特定的测试逻辑。
框架模式：
假设你正在开发一个Web应用程序，需要处理HTTP请求和响应。你可以使用框架模式来定义应用程序的基本结构和通用功能，使得开发人员可以快速搭建和扩展应用程序。
计算机访问控制模式：
假设你正在开发一个系统，需要对用户的访问进行控制和权限管理。你可以使用计算机访问控制模式来定义用户角色、权限和访问策略，以保证系统的安全性和合规性。
日志记录器模式：
假设你正在开发一个应用程序，需要记录各种操作和事件以进行调试和审计。你可以使用日志记录器模式来封装日志记录逻辑，并提供不同级别的日志输出，以满足不同的需求。
命令行模式：
假设你正在开发一个命令行工具，需要解析命令行参数并执行相应的操作。你可以使用命令行模式来定义命令对象和命令处理器，实现命令的解析和执行。
表驱动模式：
假设你正在开发一个数据转换工具，需要根据不同的输入和规则进行数据转换。你可以使用表驱动模式来定义转换规则和操作表格，使得数据转换过程更加灵活和可配置。
交易模式：
假设你正在开发一个金融交易系统，需要支持各种类型的交易操作。你可以使用交易模式来定义交易对象和交易处理器，实现交易的执行和记录。
订阅-发布模式：
假设你正在开发一个新闻订阅应用程序，用户可以订阅不同的新闻源并接收最新的新闻更新。你可以使用订阅-发布模式来实现发布者发布新闻和订阅者接收新闻的机制。服务定位器模式：
假设你正在开发一个大型应用程序，需要管理多个服务的实例和访问。你可以使用服务定位器模式来提供一个中心化的服务注册和查找机制，使得服务的获取和使用更加方便和灵活。
依赖注入模式：
假设你正在开发一个依赖关系复杂的系统，需要解耦和管理对象之间的依赖关系。你可以使用依赖注入模式来通过构造函数、属性或接口注入依赖，提高代码的可测试性和可维护性。
互斥模式：
假设你正在开发一个并发系统，需要确保多个线程之间的互斥访问。你可以使用互斥模式来实现线程之间的同步和协作，保证共享资源的正确性和一致性。
服务提供者模式：
假设你正在开发一个插件化系统，需要动态加载和管理不同的服务提供者。你可以使用服务提供者模式来定义服务接口和具体的服务实现，使得系统具有可扩展性和灵活性。
读写锁模式：
假设你正在开发一个高并发的系统，需要同时支持读操作和写操作。你可以使用读写锁模式来实现读操作的共享访问和写操作的独占访问，提高系统的并发性能和并发控制能力。
限流模式：
假设你正在开发一个网络应用程序，需要限制请求的数量或频率，以保护系统的稳定性和安全性。你可以使用限流模式来控制请求的流量，防止系统过载或被恶意攻击。
广播模式：
假设你正在开发一个实时通信应用程序，需要将消息广播给多个订阅者。你可以使用广播模式来实现消息的发布和订阅机制，使得消息能够快速传递到所有的订阅者。
负载均衡模式：
假设你正在开发一个高流量的网站，需要将请求均匀地分配到多个服务器上。你可以使用负载均衡模式来实现请求的分发和负载均衡，提高系统的性能和可用性。
缓存模式：
假设你正在开发一个系统，需要频繁地读取和计算数据。你可以使用缓存模式来将部分数据存储在内存中，加快数据的访问速度，提高系统的响应性能。
分布式锁模式：
假设你正在开发一个分布式系统，需要实现对共享资源的并发访问控制。你可以使用分布式锁模式来确保多个节点之间的互斥访问，保证共享资源的一致性和正确性。
重试模式：
假设你正在开发一个与外部系统进行通信的应用程序，需要处理网络故障和错误情况。你可以使用重试模式来自动重试失败的操作，提高系统的容错性和可靠性。
事件驱动模式：
假设你正在开发一个事件处理系统，需要处理不同类型的事件并触发相应的动作。你可以使用事件驱动模式来定义事件和事件处理器，实现松耦合的系统架构和高度可扩展的事件处理。
数据同步模式：
假设你正在开发一个多节点的分布式系统，需要保持节点之间的数据一致性。你可以使用数据同步模式来实现数据的复制和同步，确保各个节点的数据保持一致。
服务网关模式：
假设你正在开发一个微服务架构的应用程序，需要对外提供统一的入口和访问接口。你可以使用服务网关模式来实现请求的路由、认证、限流等功能，提供统一的服务访问方式。
分布式事务模式：
假设你正在开发一个分布式系统，需要保证多个操作在不同节点上的原子性和一致性。你可以使用分布式事务模式来管理跨节点的事务操作，确保分布式系统的数据一致性。
数据库连接池模式：
假设你正在开发一个高并发的数据库应用程序，需要频繁地访问数据库。你可以使用数据库连接池模式来管理数据库连接的创建和复用，提高数据库访问的性能和效率。
消息队列模式：
假设你正在开发一个异步消息处理系统，需要将消息发送到多个消费者进行处理。你可以使用消息队列模式来实现消息的发布和订阅机制，实现解耦和异步处理。
限时执行模式：
假设你正在开发一个任务调度系统，需要在指定的时间点执行某些任务。你可以使用限时执行模式来调度和执行任务，确保任务在特定的时间点执行。