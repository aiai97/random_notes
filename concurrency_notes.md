同步原语（Synchronization Primitives）是一种提供并发控制的基本机制，如锁、条件变量、原子操作等。它们用于保证线程间的正确协调和互斥访问。
锁（Lock）：锁用于控制对共享资源的访问，保证在同一时间只有一个线程（或 goroutine）可以访问共享资源，避免数据竞争和不一致性。常见的锁包括互斥锁、读写锁、重入锁等。

条件变量（Condition Variable）：条件变量用于线程间的同步和通信。它允许线程等待某个条件满足后再继续执行。通过条件变量，线程可以在满足特定条件之前等待，减少无谓的忙等待，提高线程的效率。

原子操作（Atomic Operation）：原子操作是一种具有不可分割性的操作，可以保证在多线程环境下的原子性，不会被其他线程中断。原子操作通常用于对共享变量进行读写操作，避免竞态条件和数据竞争。

互斥量（Mutex）：互斥量是一种同步原语，用于保护临界区，只允许一个线程进入临界区执行操作。互斥量可以通过加锁和解锁来实现对临界区的互斥访问。

信号量（Semaphore）：信号量是一种同步原语，用于控制对资源的访问权限。它可以控制同时访问资源的线程数目，并提供了一种限制并发度的机制。

屏障（Barrier）：屏障用于线程间的同步，使得一组线程在达到屏障点之前都被阻塞，直到所有线程都到达屏障点后才能继续执行。

并发容器（Concurrent Container）：并发容器是一种特殊的数据结构，能够安全地在并发环境中被多个线程同时访问和修改。并发容器提供了线程安全的数据访问和更新操作，如并发队列、并发哈希表等。
Java中的同步原语和并发容器：

同步原语：

synchronized 关键字：用于实现内置锁，提供对临界区的互斥访问。
ReentrantLock 类：可重入锁，提供显式的加锁和解锁操作，支持更灵活的同步控制。
Condition 接口：配合 ReentrantLock 使用，实现线程间的等待和通知机制。
并发容器：

ConcurrentHashMap 类：线程安全的哈希表实现，支持高并发的读写操作。
CopyOnWriteArrayList 类：线程安全的动态数组实现，支持并发的读操作，适用于读多写少的场景。
BlockingQueue 接口：提供线程安全的阻塞队列实现，用于实现生产者-消费者模式。
Semaphore 类：用于控制并发访问的许可数量。
CountDownLatch 类：实现线程间的等待，等待一组线程执行完毕后再继续执行。
CyclicBarrier 类：实现线程间的同步，当一组线程都达到屏障点时再继续执行。

同步原语：

sync.Mutex 类型：互斥锁，用于提供互斥访问。
sync.RWMutex 类型：读写锁，支持多个读操作或单个写操作。
sync.WaitGroup 类型：用于实现线程间的等待和通知机制。
并发容器：

sync.Map 类型：线程安全的哈希表实现。
sync.WaitGroup 类型：用于实现线程间的等待和通知机制。
chan 类型：通道，用于实现 goroutine 之间的通信和同步。


在C++中，常见的锁包括以下几种：

互斥锁（Mutex）：互斥锁是一种基本的锁类型，用于提供互斥访问，即同一时间只有一个线程可以获取到锁。C++标准库提供了 std::mutex 类来实现互斥锁。

递归锁（Recursive Lock）：递归锁允许同一线程多次获取锁，通常用于处理递归函数或嵌套代码块。C++标准库提供了 std::recursive_mutex 类来实现递归锁。

读写锁（Read-Write Lock）：读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。读写锁在读多写少的场景下可以提高并发性能。C++17标准引入了 std::shared_mutex 类来实现读写锁。

条件变量（Condition Variable）：条件变量用于线程间的同步和通信。它允许线程等待某个条件满足后再继续执行。C++标准库提供了 std::condition_variable 类和 std::condition_variable_any 类来实现条件变量。

原子操作（Atomic Operation）：原子操作是一种特殊的操作，可以保证在多线程环境下的原子性，不会被其他线程中断。C++标准库提供了 std::atomic 类和其他原子类型来实现原子操作。
